<?php

declare(strict_types=1);

namespace ContractTests;

use JsonException;
use RuntimeException;

/**
 * Immutable wrapper around parsed index.scip.json with indexed lookups.
 *
 * This class loads the SCIP JSON file (generated by `scip print --json`)
 * and provides efficient access to documents, symbols, and occurrences.
 */
final class ScipData
{
    /** @var array<string, mixed> */
    private array $metadata = [];

    /** @var list<array<string, mixed>> */
    private array $documents = [];

    /** @var array<string, array<string, mixed>> Index: symbol string -> symbol info */
    private array $symbolsByName = [];

    /** @var array<string, list<array<string, mixed>>> Index: symbol string -> occurrences */
    private array $occurrencesBySymbol = [];

    /** @var array<string, list<array<string, mixed>>> Index: file path -> occurrences */
    private array $occurrencesByFile = [];

    /** @var array<string, array<string, mixed>> Index: file path -> document */
    private array $documentsByPath = [];

    private function __construct()
    {
    }

    /**
     * Load SCIP data from a JSON file.
     *
     * @throws RuntimeException if file doesn't exist or can't be read
     * @throws JsonException if JSON is invalid
     */
    public static function load(string $path): self
    {
        if (!file_exists($path)) {
            throw new RuntimeException(
                sprintf('index.scip.json not found at: %s', $path)
            );
        }

        $content = file_get_contents($path);
        if ($content === false) {
            throw new RuntimeException(
                sprintf('Failed to read index.scip.json at: %s', $path)
            );
        }

        $data = json_decode($content, true, 512, JSON_THROW_ON_ERROR);

        return self::fromArray($data);
    }

    /**
     * Create ScipData from a parsed array.
     *
     * @param array{metadata?: array<string, mixed>, documents?: list<array<string, mixed>>} $data
     */
    public static function fromArray(array $data): self
    {
        $instance = new self();
        $instance->metadata = $data['metadata'] ?? [];
        $instance->documents = $data['documents'] ?? [];

        // Build indices
        foreach ($instance->documents as $document) {
            $relativePath = $document['relativePath'] ?? $document['relative_path'] ?? '';

            // Index document by path
            if ($relativePath !== '') {
                $instance->documentsByPath[$relativePath] = $document;
            }

            // Index symbols
            $symbols = $document['symbols'] ?? [];
            foreach ($symbols as $symbolInfo) {
                $symbolName = $symbolInfo['symbol'] ?? '';
                if ($symbolName !== '') {
                    $instance->symbolsByName[$symbolName] = $symbolInfo;
                }
            }

            // Index occurrences
            $occurrences = $document['occurrences'] ?? [];
            foreach ($occurrences as $occurrence) {
                // Add file path to occurrence for easier querying
                $occurrenceWithFile = $occurrence;
                $occurrenceWithFile['_file'] = $relativePath;

                // Index by symbol
                $symbolName = $occurrence['symbol'] ?? '';
                if ($symbolName !== '') {
                    $instance->occurrencesBySymbol[$symbolName] ??= [];
                    $instance->occurrencesBySymbol[$symbolName][] = $occurrenceWithFile;
                }

                // Index by file
                if ($relativePath !== '') {
                    $instance->occurrencesByFile[$relativePath] ??= [];
                    $instance->occurrencesByFile[$relativePath][] = $occurrenceWithFile;
                }
            }
        }

        return $instance;
    }

    /**
     * Get the SCIP metadata.
     *
     * @return array<string, mixed>
     */
    public function metadata(): array
    {
        return $this->metadata;
    }

    /**
     * Get all documents.
     *
     * @return list<array<string, mixed>>
     */
    public function documents(): array
    {
        return $this->documents;
    }

    /**
     * Get a document by its relative path.
     *
     * @return array<string, mixed>|null
     */
    public function getDocumentByPath(string $path): ?array
    {
        return $this->documentsByPath[$path] ?? null;
    }

    /**
     * Get all symbols across all documents.
     *
     * @return array<string, array<string, mixed>>
     */
    public function symbols(): array
    {
        return $this->symbolsByName;
    }

    /**
     * Get a symbol by its full SCIP symbol name.
     *
     * @return array<string, mixed>|null
     */
    public function getSymbol(string $symbol): ?array
    {
        return $this->symbolsByName[$symbol] ?? null;
    }

    /**
     * Check if a symbol exists.
     */
    public function hasSymbol(string $symbol): bool
    {
        return isset($this->symbolsByName[$symbol]);
    }

    /**
     * Get all occurrences for a symbol.
     *
     * @return list<array<string, mixed>>
     */
    public function occurrences(string $symbol): array
    {
        return $this->occurrencesBySymbol[$symbol] ?? [];
    }

    /**
     * Get all occurrences in a file.
     *
     * @return list<array<string, mixed>>
     */
    public function occurrencesInFile(string $path): array
    {
        return $this->occurrencesByFile[$path] ?? [];
    }

    /**
     * Get relationships for a symbol.
     *
     * @return list<array<string, mixed>>
     */
    public function relationships(string $symbol): array
    {
        $symbolInfo = $this->symbolsByName[$symbol] ?? null;
        if ($symbolInfo === null) {
            return [];
        }

        return $symbolInfo['relationships'] ?? [];
    }

    /**
     * Get all file paths in the index.
     *
     * @return list<string>
     */
    public function filePaths(): array
    {
        return array_keys($this->documentsByPath);
    }

    /**
     * Get total count of documents.
     */
    public function documentCount(): int
    {
        return count($this->documents);
    }

    /**
     * Get total count of unique symbols.
     */
    public function symbolCount(): int
    {
        return count($this->symbolsByName);
    }

    /**
     * Find symbols matching a pattern (supports * wildcard).
     *
     * @return list<string>
     */
    public function findSymbols(string $pattern): array
    {
        $regex = '/^' . str_replace(
            ['\\*', '\\?'],
            ['.*', '.'],
            preg_quote($pattern, '/')
        ) . '$/';

        $matches = [];
        foreach (array_keys($this->symbolsByName) as $symbol) {
            if (preg_match($regex, $symbol) === 1) {
                $matches[] = $symbol;
            }
        }

        return $matches;
    }
}
